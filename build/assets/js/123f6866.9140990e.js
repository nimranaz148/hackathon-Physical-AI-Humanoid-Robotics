"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[315],{8453(n,e,r){r.d(e,{R:()=>o,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function o(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(t.Provider,{value:e},n.children)}},9844(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module4/week12-humanoid-dev-2","title":"Manipulation and Human-Robot Interaction","description":"Humanoid manipulation, grasping, and designing natural human-robot interaction","source":"@site/docs/module4/week12-humanoid-dev-2.md","sourceDirName":"module4","slug":"/module4/week12-humanoid-dev-2","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week12-humanoid-dev-2","draft":false,"unlisted":false,"editUrl":"https://github.com/nimranaz148/docs/module4/week12-humanoid-dev-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Manipulation and Human-Robot Interaction","description":"Humanoid manipulation, grasping, and designing natural human-robot interaction","keywords":["manipulation","grasping","human-robot-interaction","hri","gripper","dexterous"]},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Kinematics and Dynamics","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week11-humanoid-dev"},"next":{"title":"Conversational Robotics & VLA Models","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week13-conversational-robotics"}}');var s=r(4848),t=r(8453);const o={sidebar_position:2,title:"Manipulation and Human-Robot Interaction",description:"Humanoid manipulation, grasping, and designing natural human-robot interaction",keywords:["manipulation","grasping","human-robot-interaction","hri","gripper","dexterous"]},a="Manipulation and Human-Robot Interaction",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"The Physics (Why)",id:"the-physics-why",level:2},{value:"The Analogy (Mental Model)",id:"the-analogy-mental-model",level:2},{value:"The Visualization (Manipulation Pipeline)",id:"the-visualization-manipulation-pipeline",level:2},{value:"The Code (Implementation)",id:"the-code-implementation",level:2},{value:"Grasp Planning",id:"grasp-planning",level:3},{value:"Force Control for Compliant Manipulation",id:"force-control-for-compliant-manipulation",level:3},{value:"ROS 2 Manipulation Node",id:"ros-2-manipulation-node",level:3},{value:"The Hardware Reality (Warning)",id:"the-hardware-reality-warning",level:2},{value:"Assessment",id:"assessment",level:2},{value:"Recall",id:"recall",level:3},{value:"Apply",id:"apply",level:3},{value:"Analyze",id:"analyze",level:3}];function d(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"manipulation-and-human-robot-interaction",children:"Manipulation and Human-Robot Interaction"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you should be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understand grasp planning and manipulation strategies"}),"\n",(0,s.jsx)(e.li,{children:"Implement basic pick-and-place operations"}),"\n",(0,s.jsx)(e.li,{children:"Design safe human-robot interaction systems"}),"\n",(0,s.jsx)(e.li,{children:"Use force control for compliant manipulation"}),"\n",(0,s.jsx)(e.li,{children:"Recognize the challenges of dexterous manipulation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"the-physics-why",children:"The Physics (Why)"}),"\n",(0,s.jsxs)(e.p,{children:["Manipulation is fundamentally about ",(0,s.jsx)(e.strong,{children:"controlling contact forces"}),". When a robot grasps an object:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Normal forces"})," prevent the object from falling through the gripper"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction forces"})," prevent the object from slipping"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Torques"})," control object orientation"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["The challenge is that contact is ",(0,s.jsx)(e.strong,{children:"discontinuous"}),"\u2014forces change abruptly when contact is made or broken. This makes manipulation much harder than free-space motion."]}),"\n",(0,s.jsx)(e.p,{children:"For human-robot interaction, safety requires:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force limiting"}),": Never apply dangerous forces to humans"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Compliance"}),": Yield to unexpected contacts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Predictability"}),": Humans must understand robot intentions"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"the-analogy-mental-model",children:"The Analogy (Mental Model)"}),"\n",(0,s.jsxs)(e.p,{children:["Think of robot manipulation like ",(0,s.jsx)(e.strong,{children:"learning to use chopsticks"}),":"]}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Chopstick Challenge"}),(0,s.jsx)(e.th,{children:"Robot Equivalent"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Coordinating two sticks"}),(0,s.jsx)(e.td,{children:"Coordinating multiple fingers"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Feeling food texture"}),(0,s.jsx)(e.td,{children:"Force/tactile sensing"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Adjusting grip pressure"}),(0,s.jsx)(e.td,{children:"Force control"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Not dropping food"}),(0,s.jsx)(e.td,{children:"Grasp stability"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Not crushing soft food"}),(0,s.jsx)(e.td,{children:"Compliance control"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:"Just as chopstick mastery requires years of practice, dexterous robot manipulation remains an open research problem."}),"\n",(0,s.jsx)(e.h2,{id:"the-visualization-manipulation-pipeline",children:"The Visualization (Manipulation Pipeline)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mermaid",children:'graph TB\r\n    subgraph "Perception"\r\n        A[RGB-D Camera] --\x3e B[Object Detection]\r\n        B --\x3e C[Pose Estimation]\r\n        C --\x3e D[Grasp Planning]\r\n    end\r\n    \r\n    subgraph "Planning"\r\n        D --\x3e E[Approach Path]\r\n        E --\x3e F[Grasp Execution]\r\n        F --\x3e G[Lift & Transport]\r\n        G --\x3e H[Place]\r\n    end\r\n    \r\n    subgraph "Control"\r\n        F --\x3e I[Force Control]\r\n        I --\x3e J[Gripper Commands]\r\n        K[Force Sensor] --\x3e I\r\n    end\r\n    \r\n    subgraph "Safety"\r\n        L[Collision Detection] --\x3e M[Emergency Stop]\r\n        N[Human Detection] --\x3e O[Speed Limiting]\r\n    end\n'})}),"\n",(0,s.jsx)(e.h2,{id:"the-code-implementation",children:"The Code (Implementation)"}),"\n",(0,s.jsx)(e.h3,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\ngrasp_planning.py - Plan grasps for object manipulation.\r\n"""\r\n\r\nimport numpy as np\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Tuple, Optional\r\n\r\n\r\n@dataclass\r\nclass GraspPose:\r\n    """Represents a candidate grasp."""\r\n    position: np.ndarray      # Gripper position\r\n    orientation: np.ndarray   # Quaternion\r\n    width: float              # Gripper opening width\r\n    quality: float            # Grasp quality score\r\n\r\n\r\n@dataclass\r\nclass ObjectInfo:\r\n    """Information about object to grasp."""\r\n    position: np.ndarray\r\n    dimensions: np.ndarray    # (length, width, height)\r\n    mass: float\r\n    friction_coef: float\r\n\r\n\r\nclass GraspPlanner:\r\n    """Plan stable grasps for objects."""\r\n    \r\n    def __init__(self, gripper_max_width: float = 0.1):\r\n        self.gripper_max_width = gripper_max_width\r\n        self.min_friction = 0.3\r\n    \r\n    def plan_grasps(\r\n        self,\r\n        obj: ObjectInfo,\r\n        num_candidates: int = 10\r\n    ) -> List[GraspPose]:\r\n        """\r\n        Generate candidate grasps for an object.\r\n        \r\n        Uses antipodal grasp heuristic: grasp along object\'s\r\n        shortest dimension for stability.\r\n        """\r\n        candidates = []\r\n        \r\n        # Find graspable dimension (must fit in gripper)\r\n        dims = obj.dimensions\r\n        graspable_dims = [i for i, d in enumerate(dims) if d < self.gripper_max_width]\r\n        \r\n        if not graspable_dims:\r\n            return []  # Object too large\r\n        \r\n        # Generate grasps along each graspable axis\r\n        for dim_idx in graspable_dims:\r\n            for angle in np.linspace(0, np.pi, num_candidates // len(graspable_dims)):\r\n                grasp = self.generate_grasp(obj, dim_idx, angle)\r\n                if grasp:\r\n                    candidates.append(grasp)\r\n        \r\n        # Sort by quality\r\n        candidates.sort(key=lambda g: g.quality, reverse=True)\r\n        \r\n        return candidates\r\n    \r\n    def generate_grasp(\r\n        self,\r\n        obj: ObjectInfo,\r\n        grasp_axis: int,\r\n        rotation: float\r\n    ) -> Optional[GraspPose]:\r\n        """Generate a single grasp candidate."""\r\n        # Position at object center\r\n        position = obj.position.copy()\r\n        \r\n        # Orientation based on grasp axis\r\n        # (simplified - real implementation uses proper rotation matrices)\r\n        orientation = np.array([0, 0, np.sin(rotation/2), np.cos(rotation/2)])\r\n        \r\n        # Width slightly larger than object dimension\r\n        width = obj.dimensions[grasp_axis] + 0.01\r\n        \r\n        # Quality based on friction and stability\r\n        quality = self.evaluate_grasp_quality(obj, grasp_axis)\r\n        \r\n        return GraspPose(\r\n            position=position,\r\n            orientation=orientation,\r\n            width=width,\r\n            quality=quality\r\n        )\r\n    \r\n    def evaluate_grasp_quality(self, obj: ObjectInfo, grasp_axis: int) -> float:\r\n        """\r\n        Evaluate grasp quality using force closure analysis.\r\n        \r\n        Higher quality = more stable grasp.\r\n        """\r\n        # Simplified quality metric\r\n        # Real implementation would use GraspIt! or similar\r\n        \r\n        # Prefer grasping along shortest dimension\r\n        dims = obj.dimensions\r\n        dim_score = 1.0 - (dims[grasp_axis] / max(dims))\r\n        \r\n        # Friction score\r\n        friction_score = min(1.0, obj.friction_coef / self.min_friction)\r\n        \r\n        # Mass penalty (heavier objects harder to grasp)\r\n        mass_score = 1.0 / (1.0 + obj.mass / 5.0)\r\n        \r\n        return 0.4 * dim_score + 0.4 * friction_score + 0.2 * mass_score\r\n\r\n\r\nclass PickAndPlace:\r\n    """Execute pick and place operations."""\r\n    \r\n    def __init__(self, arm_controller, gripper_controller):\r\n        self.arm = arm_controller\r\n        self.gripper = gripper_controller\r\n        self.planner = GraspPlanner()\r\n    \r\n    def pick(self, obj: ObjectInfo) -> bool:\r\n        """Pick up an object."""\r\n        # Plan grasp\r\n        grasps = self.planner.plan_grasps(obj)\r\n        if not grasps:\r\n            return False\r\n        \r\n        best_grasp = grasps[0]\r\n        \r\n        # Open gripper\r\n        self.gripper.open(best_grasp.width + 0.02)\r\n        \r\n        # Move to pre-grasp position (above object)\r\n        pre_grasp = best_grasp.position.copy()\r\n        pre_grasp[2] += 0.1  # 10cm above\r\n        self.arm.move_to(pre_grasp, best_grasp.orientation)\r\n        \r\n        # Move to grasp position\r\n        self.arm.move_to(best_grasp.position, best_grasp.orientation)\r\n        \r\n        # Close gripper\r\n        success = self.gripper.close(force_limit=20.0)\r\n        \r\n        if success:\r\n            # Lift object\r\n            lift_pos = best_grasp.position.copy()\r\n            lift_pos[2] += 0.15\r\n            self.arm.move_to(lift_pos, best_grasp.orientation)\r\n        \r\n        return success\r\n    \r\n    def place(self, target_position: np.ndarray) -> bool:\r\n        """Place held object at target position."""\r\n        # Move above target\r\n        above_target = target_position.copy()\r\n        above_target[2] += 0.1\r\n        self.arm.move_to(above_target)\r\n        \r\n        # Lower to target\r\n        self.arm.move_to(target_position)\r\n        \r\n        # Open gripper\r\n        self.gripper.open()\r\n        \r\n        # Retreat\r\n        self.arm.move_to(above_target)\r\n        \r\n        return True\n'})}),"\n",(0,s.jsx)(e.h3,{id:"force-control-for-compliant-manipulation",children:"Force Control for Compliant Manipulation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nforce_control.py - Compliant manipulation with force feedback.\r\n"""\r\n\r\nimport numpy as np\r\nfrom dataclasses import dataclass\r\nfrom typing import Tuple\r\n\r\n\r\n@dataclass\r\nclass ForceReading:\r\n    """6-axis force/torque reading."""\r\n    force: np.ndarray   # (fx, fy, fz)\r\n    torque: np.ndarray  # (tx, ty, tz)\r\n\r\n\r\nclass ImpedanceController:\r\n    """\r\n    Impedance control for compliant manipulation.\r\n    \r\n    Makes the robot behave like a mass-spring-damper system,\r\n    allowing safe interaction with environment and humans.\r\n    """\r\n    \r\n    def __init__(\r\n        self,\r\n        stiffness: np.ndarray = None,\r\n        damping: np.ndarray = None,\r\n        mass: np.ndarray = None\r\n    ):\r\n        # Default parameters (can be tuned per task)\r\n        self.K = stiffness if stiffness is not None else np.array([500, 500, 500])\r\n        self.D = damping if damping is not None else np.array([50, 50, 50])\r\n        self.M = mass if mass is not None else np.array([1, 1, 1])\r\n        \r\n        # State\r\n        self.position = np.zeros(3)\r\n        self.velocity = np.zeros(3)\r\n    \r\n    def compute_command(\r\n        self,\r\n        desired_position: np.ndarray,\r\n        current_position: np.ndarray,\r\n        current_velocity: np.ndarray,\r\n        external_force: np.ndarray\r\n    ) -> np.ndarray:\r\n        """\r\n        Compute position command with impedance behavior.\r\n        \r\n        F = M*a + D*v + K*x\r\n        \r\n        The robot will yield to external forces while trying\r\n        to reach the desired position.\r\n        """\r\n        # Position error\r\n        pos_error = desired_position - current_position\r\n        \r\n        # Impedance equation: solve for acceleration\r\n        # M*a = F_ext - D*v - K*x\r\n        acceleration = (\r\n            external_force - \r\n            self.D * current_velocity - \r\n            self.K * pos_error\r\n        ) / self.M\r\n        \r\n        # Integrate to get velocity and position\r\n        dt = 0.01  # 100 Hz control\r\n        new_velocity = current_velocity + acceleration * dt\r\n        new_position = current_position + new_velocity * dt\r\n        \r\n        return new_position\r\n    \r\n    def set_stiffness(self, stiffness: np.ndarray):\r\n        """Adjust stiffness (higher = stiffer, less compliant)."""\r\n        self.K = np.clip(stiffness, 10, 2000)\r\n    \r\n    def set_compliant_mode(self):\r\n        """Set low stiffness for safe human interaction."""\r\n        self.K = np.array([100, 100, 100])\r\n        self.D = np.array([20, 20, 20])\r\n    \r\n    def set_stiff_mode(self):\r\n        """Set high stiffness for precise positioning."""\r\n        self.K = np.array([1000, 1000, 1000])\r\n        self.D = np.array([100, 100, 100])\r\n\r\n\r\nclass SafeHumanInteraction:\r\n    """Safety system for human-robot interaction."""\r\n    \r\n    def __init__(self):\r\n        # Safety limits\r\n        self.max_force = 50.0      # Newtons\r\n        self.max_speed = 0.5       # m/s near humans\r\n        self.min_distance = 0.3   # meters\r\n        \r\n        # State\r\n        self.human_detected = False\r\n        self.human_distance = float(\'inf\')\r\n    \r\n    def update_human_detection(self, distance: float):\r\n        """Update human proximity information."""\r\n        self.human_distance = distance\r\n        self.human_detected = distance < 2.0\r\n    \r\n    def get_safe_speed_limit(self) -> float:\r\n        """Get speed limit based on human proximity."""\r\n        if not self.human_detected:\r\n            return 1.0  # Full speed\r\n        \r\n        if self.human_distance < self.min_distance:\r\n            return 0.0  # Stop\r\n        \r\n        # Linear scaling between min_distance and 2m\r\n        scale = (self.human_distance - self.min_distance) / (2.0 - self.min_distance)\r\n        return self.max_speed * scale\r\n    \r\n    def check_force_limit(self, force: ForceReading) -> Tuple[bool, str]:\r\n        """Check if force exceeds safety limits."""\r\n        force_magnitude = np.linalg.norm(force.force)\r\n        \r\n        if force_magnitude > self.max_force:\r\n            return False, f"Force limit exceeded: {force_magnitude:.1f}N > {self.max_force}N"\r\n        \r\n        return True, "OK"\r\n    \r\n    def should_emergency_stop(self, force: ForceReading) -> bool:\r\n        """Determine if emergency stop is needed."""\r\n        force_magnitude = np.linalg.norm(force.force)\r\n        \r\n        # Emergency stop if force is way over limit\r\n        if force_magnitude > self.max_force * 1.5:\r\n            return True\r\n        \r\n        # Emergency stop if human too close\r\n        if self.human_distance < 0.1:\r\n            return True\r\n        \r\n        return False\n'})}),"\n",(0,s.jsx)(e.h3,{id:"ros-2-manipulation-node",children:"ROS 2 Manipulation Node"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nmanipulation_node.py - ROS 2 node for manipulation tasks.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, WrenchStamped\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import Bool\r\nimport numpy as np\r\n\r\n\r\nclass ManipulationNode(Node):\r\n    """ROS 2 node for humanoid manipulation."""\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'manipulation_node\')\r\n        \r\n        # Controllers\r\n        self.impedance = ImpedanceController()\r\n        self.safety = SafeHumanInteraction()\r\n        \r\n        # State\r\n        self.current_pose = None\r\n        self.current_force = None\r\n        self.target_pose = None\r\n        \r\n        # Subscribers\r\n        self.pose_sub = self.create_subscription(\r\n            PoseStamped, \'/arm/current_pose\', self.pose_callback, 10\r\n        )\r\n        self.force_sub = self.create_subscription(\r\n            WrenchStamped, \'/arm/force_torque\', self.force_callback, 10\r\n        )\r\n        self.target_sub = self.create_subscription(\r\n            PoseStamped, \'/arm/target_pose\', self.target_callback, 10\r\n        )\r\n        \r\n        # Publishers\r\n        self.cmd_pub = self.create_publisher(\r\n            PoseStamped, \'/arm/command_pose\', 10\r\n        )\r\n        self.stop_pub = self.create_publisher(\r\n            Bool, \'/emergency_stop\', 10\r\n        )\r\n        \r\n        # Control loop at 100 Hz\r\n        self.timer = self.create_timer(0.01, self.control_loop)\r\n        \r\n        self.get_logger().info(\'Manipulation node started\')\r\n    \r\n    def pose_callback(self, msg: PoseStamped):\r\n        """Update current end-effector pose."""\r\n        self.current_pose = np.array([\r\n            msg.pose.position.x,\r\n            msg.pose.position.y,\r\n            msg.pose.position.z\r\n        ])\r\n    \r\n    def force_callback(self, msg: WrenchStamped):\r\n        """Update force/torque reading."""\r\n        self.current_force = ForceReading(\r\n            force=np.array([\r\n                msg.wrench.force.x,\r\n                msg.wrench.force.y,\r\n                msg.wrench.force.z\r\n            ]),\r\n            torque=np.array([\r\n                msg.wrench.torque.x,\r\n                msg.wrench.torque.y,\r\n                msg.wrench.torque.z\r\n            ])\r\n        )\r\n    \r\n    def target_callback(self, msg: PoseStamped):\r\n        """Update target pose."""\r\n        self.target_pose = np.array([\r\n            msg.pose.position.x,\r\n            msg.pose.position.y,\r\n            msg.pose.position.z\r\n        ])\r\n    \r\n    def control_loop(self):\r\n        """Main control loop with safety checks."""\r\n        if self.current_pose is None or self.target_pose is None:\r\n            return\r\n        \r\n        # Safety checks\r\n        if self.current_force:\r\n            if self.safety.should_emergency_stop(self.current_force):\r\n                self.emergency_stop()\r\n                return\r\n            \r\n            safe, msg = self.safety.check_force_limit(self.current_force)\r\n            if not safe:\r\n                self.get_logger().warn(msg)\r\n                self.impedance.set_compliant_mode()\r\n        \r\n        # Compute command with impedance control\r\n        external_force = self.current_force.force if self.current_force else np.zeros(3)\r\n        \r\n        command_pos = self.impedance.compute_command(\r\n            desired_position=self.target_pose,\r\n            current_position=self.current_pose,\r\n            current_velocity=np.zeros(3),  # Would come from velocity estimation\r\n            external_force=external_force\r\n        )\r\n        \r\n        # Publish command\r\n        cmd_msg = PoseStamped()\r\n        cmd_msg.header.stamp = self.get_clock().now().to_msg()\r\n        cmd_msg.pose.position.x = command_pos[0]\r\n        cmd_msg.pose.position.y = command_pos[1]\r\n        cmd_msg.pose.position.z = command_pos[2]\r\n        \r\n        self.cmd_pub.publish(cmd_msg)\r\n    \r\n    def emergency_stop(self):\r\n        """Trigger emergency stop."""\r\n        self.get_logger().error(\'EMERGENCY STOP\')\r\n        stop_msg = Bool()\r\n        stop_msg.data = True\r\n        self.stop_pub.publish(stop_msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ManipulationNode()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"the-hardware-reality-warning",children:"The Hardware Reality (Warning)"}),"\n",(0,s.jsxs)(e.admonition,{title:"Human Safety is Paramount",type:"danger",children:[(0,s.jsx)(e.p,{children:"When robots interact with humans:"}),(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ISO 10218"}),": Industrial robot safety standards"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"ISO/TS 15066"}),": Collaborative robot safety"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Force limits"}),": Max 150N transient, 65N quasi-static for human contact"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Speed limits"}),": Max 250mm/s in collaborative mode"]}),"\n"]}),(0,s.jsx)(e.p,{children:"Violating these limits can cause serious injury."})]}),"\n",(0,s.jsxs)(e.admonition,{title:"Gripper Selection",type:"warning",children:[(0,s.jsx)(e.p,{children:"Choose grippers based on task requirements:"}),(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Gripper Type"}),(0,s.jsx)(e.th,{children:"Payload"}),(0,s.jsx)(e.th,{children:"Dexterity"}),(0,s.jsx)(e.th,{children:"Cost"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Parallel jaw"}),(0,s.jsx)(e.td,{children:"High"}),(0,s.jsx)(e.td,{children:"Low"}),(0,s.jsx)(e.td,{children:"$500-2k"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Soft gripper"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"$1k-5k"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Dexterous hand"}),(0,s.jsx)(e.td,{children:"Low"}),(0,s.jsx)(e.td,{children:"High"}),(0,s.jsx)(e.td,{children:"$20k-100k"})]})]})]}),(0,s.jsx)(e.p,{children:"Most humanoid applications use parallel jaw grippers for reliability."})]}),"\n",(0,s.jsx)(e.h2,{id:"assessment",children:"Assessment"}),"\n",(0,s.jsx)(e.h3,{id:"recall",children:"Recall"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"What is impedance control and why is it important for manipulation?"}),"\n",(0,s.jsx)(e.li,{children:"What are the ISO safety standards for collaborative robots?"}),"\n",(0,s.jsx)(e.li,{children:"What is an antipodal grasp?"}),"\n",(0,s.jsx)(e.li,{children:"Why is force sensing important for manipulation?"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"apply",children:"Apply"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Implement a grasp planner for cylindrical objects (cups, bottles)."}),"\n",(0,s.jsx)(e.li,{children:"Write a safety monitor that limits robot speed based on human proximity."}),"\n",(0,s.jsx)(e.li,{children:"Design an impedance controller that becomes more compliant when force exceeds a threshold."}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"analyze",children:"Analyze"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Compare the trade-offs between position control and force control for manipulation."}),"\n",(0,s.jsx)(e.li,{children:"Why is dexterous manipulation with multi-fingered hands still an open research problem?"}),"\n",(0,s.jsx)(e.li,{children:"Design a human-robot handover protocol that is both safe and efficient."}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);